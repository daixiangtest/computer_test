{"name": "验证端口映射", "status": "broken", "statusDetails": {"message": "TypeError: not all arguments converted during string formatting", "trace": "self = <paramiko.Transport at 0x95bc31f0 (unconnected)>\n\n    def _check_banner(self):\n        # this is slow, but we only have to do it once\n        for i in range(100):\n            # give them 15 seconds for the first line, then just 2 seconds\n            # each additional line.  (some sites have very high latency.)\n            if i == 0:\n                timeout = self.banner_timeout\n            else:\n                timeout = 2\n            try:\n>               buf = self.packetizer.readline(timeout)\n\nD:\\Python\\lib\\site-packages\\paramiko\\transport.py:2292: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <paramiko.packet.Packetizer object at 0x000001E895B9B3A0>, timeout = 15\n\n    def readline(self, timeout):\n        \"\"\"\n        Read a line from the socket.  We assume no data is pending after the\n        line, so it's okay to attempt large reads.\n        \"\"\"\n        buf = self.__remainder\n        while linefeed_byte not in buf:\n>           buf += self._read_timeout(timeout)\n\nD:\\Python\\lib\\site-packages\\paramiko\\packet.py:374: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <paramiko.packet.Packetizer object at 0x000001E895B9B3A0>, timeout = 15\n\n    def _read_timeout(self, timeout):\n        start = time.time()\n        while True:\n            try:\n>               x = self.__socket.recv(128)\nE               ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。\n\nD:\\Python\\lib\\site-packages\\paramiko\\packet.py:601: ConnectionResetError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <computer_test.test_cases.test_interfaces.test_cloud_server.TestCloudServer object at 0x000001E895AF7850>\n\n    @allure.suite('云服务器')\n    @allure.description(\"验证端口映射\")\n    # @pytest.mark.skip('暂时跳过')\n    def test_check_mapping(self):\n        case = self.cases[3]\n        allure.dynamic.title(case['case_title'])\n        allure.attach(body=self.cs.host, name=\"请求地址\")\n        try:\n            time.sleep(5)\n            public_ip = get_ini_data(CFI_COMPUTER, 'mapping', 'public_ip')\n            public_port = get_ini_data(CFI_COMPUTER, 'mapping', 'public_port')\n            username = case['case_data']['name']\n            passwd = case['case_data']['passwd']\n            print(public_ip, public_port, username, passwd)\n>           mc = MySshClient(public_ip, public_port, username, str(passwd))\n\ntest_cases\\test_interfaces\\test_cloud_server.py:114: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <comms.my_ssh_client.MySshClient object at 0x000001E895AF73A0>\nhost = '61.172.179.73', port = '41109', username = 'ubuntu', passwd = '123456'\n\n    def __init__(self, host, port, username, passwd):\n        # 创建链接\n        try:\n            ssh = paramiko.SSHClient()  # 创建链接对象\n            ssh.set_missing_host_key_policy(paramiko.WarningPolicy())  # 选择链接方式\n            ssh.load_system_host_keys()\n            ssh.connect(host, port, username, passwd, timeout=5)  # 输入链接信息进行链接\n            self.ssh = ssh\n        except Exception as e:\n            print(f\"链接服务器{host}:{port}失败\")\n            get_logger().error(f\"链接服务器{host}:{port}失败\")\n>           raise e\n\ncomms\\my_ssh_client.py:20: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <comms.my_ssh_client.MySshClient object at 0x000001E895AF73A0>\nhost = '61.172.179.73', port = '41109', username = 'ubuntu', passwd = '123456'\n\n    def __init__(self, host, port, username, passwd):\n        # 创建链接\n        try:\n            ssh = paramiko.SSHClient()  # 创建链接对象\n            ssh.set_missing_host_key_policy(paramiko.WarningPolicy())  # 选择链接方式\n            ssh.load_system_host_keys()\n>           ssh.connect(host, port, username, passwd, timeout=5)  # 输入链接信息进行链接\n\ncomms\\my_ssh_client.py:15: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <paramiko.client.SSHClient object at 0x000001E895BD5D30>\nhostname = '61.172.179.73', port = '41109', username = 'ubuntu'\npassword = '123456', pkey = None, key_filename = None, timeout = 5\nallow_agent = True, look_for_keys = True, compress = False\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0>\ngss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None\nbanner_timeout = None, auth_timeout = None, channel_timeout = None\ngss_trust_dns = True, passphrase = None, disabled_algorithms = None\ntransport_factory = <class 'paramiko.transport.Transport'>, auth_strategy = None\n\n    def connect(\n        self,\n        hostname,\n        port=SSH_PORT,\n        username=None,\n        password=None,\n        pkey=None,\n        key_filename=None,\n        timeout=None,\n        allow_agent=True,\n        look_for_keys=True,\n        compress=False,\n        sock=None,\n        gss_auth=False,\n        gss_kex=False,\n        gss_deleg_creds=True,\n        gss_host=None,\n        banner_timeout=None,\n        auth_timeout=None,\n        channel_timeout=None,\n        gss_trust_dns=True,\n        passphrase=None,\n        disabled_algorithms=None,\n        transport_factory=None,\n        auth_strategy=None,\n    ):\n        \"\"\"\n        Connect to an SSH server and authenticate to it.  The server's host key\n        is checked against the system host keys (see `load_system_host_keys`)\n        and any local host keys (`load_host_keys`).  If the server's hostname\n        is not found in either set of host keys, the missing host key policy\n        is used (see `set_missing_host_key_policy`).  The default policy is\n        to reject the key and raise an `.SSHException`.\n    \n        Authentication is attempted in the following order of priority:\n    \n            - The ``pkey`` or ``key_filename`` passed in (if any)\n    \n              - ``key_filename`` may contain OpenSSH public certificate paths\n                as well as regular private-key paths; when files ending in\n                ``-cert.pub`` are found, they are assumed to match a private\n                key, and both components will be loaded. (The private key\n                itself does *not* need to be listed in ``key_filename`` for\n                this to occur - *just* the certificate.)\n    \n            - Any key we can find through an SSH agent\n            - Any \"id_rsa\", \"id_dsa\" or \"id_ecdsa\" key discoverable in\n              ``~/.ssh/``\n    \n              - When OpenSSH-style public certificates exist that match an\n                existing such private key (so e.g. one has ``id_rsa`` and\n                ``id_rsa-cert.pub``) the certificate will be loaded alongside\n                the private key and used for authentication.\n    \n            - Plain username/password auth, if a password was given\n    \n        If a private key requires a password to unlock it, and a password is\n        passed in, that password will be used to attempt to unlock the key.\n    \n        :param str hostname: the server to connect to\n        :param int port: the server port to connect to\n        :param str username:\n            the username to authenticate as (defaults to the current local\n            username)\n        :param str password:\n            Used for password authentication; is also used for private key\n            decryption if ``passphrase`` is not given.\n        :param str passphrase:\n            Used for decrypting private keys.\n        :param .PKey pkey: an optional private key to use for authentication\n        :param str key_filename:\n            the filename, or list of filenames, of optional private key(s)\n            and/or certs to try for authentication\n        :param float timeout:\n            an optional timeout (in seconds) for the TCP connect\n        :param bool allow_agent:\n            set to False to disable connecting to the SSH agent\n        :param bool look_for_keys:\n            set to False to disable searching for discoverable private key\n            files in ``~/.ssh/``\n        :param bool compress: set to True to turn on compression\n        :param socket sock:\n            an open socket or socket-like object (such as a `.Channel`) to use\n            for communication to the target host\n        :param bool gss_auth:\n            ``True`` if you want to use GSS-API authentication\n        :param bool gss_kex:\n            Perform GSS-API Key Exchange and user authentication\n        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not\n        :param str gss_host:\n            The targets name in the kerberos database. default: hostname\n        :param bool gss_trust_dns:\n            Indicates whether or not the DNS is trusted to securely\n            canonicalize the name of the host being connected to (default\n            ``True``).\n        :param float banner_timeout: an optional timeout (in seconds) to wait\n            for the SSH banner to be presented.\n        :param float auth_timeout: an optional timeout (in seconds) to wait for\n            an authentication response.\n        :param float channel_timeout: an optional timeout (in seconds) to wait\n             for a channel open response.\n        :param dict disabled_algorithms:\n            an optional dict passed directly to `.Transport` and its keyword\n            argument of the same name.\n        :param transport_factory:\n            an optional callable which is handed a subset of the constructor\n            arguments (primarily those related to the socket, GSS\n            functionality, and algorithm selection) and generates a\n            `.Transport` instance to be used by this client. Defaults to\n            `.Transport.__init__`.\n        :param auth_strategy:\n            an optional instance of `.AuthStrategy`, triggering use of this\n            newer authentication mechanism instead of SSHClient's legacy auth\n            method.\n    \n            .. warning::\n                This parameter is **incompatible** with all other\n                authentication-related parameters (such as, but not limited to,\n                ``password``, ``key_filename`` and ``allow_agent``) and will\n                trigger an exception if given alongside them.\n    \n        :returns:\n            `.AuthResult` if ``auth_strategy`` is non-``None``; otherwise,\n            returns ``None``.\n    \n        :raises BadHostKeyException:\n            if the server's host key could not be verified.\n        :raises AuthenticationException:\n            if authentication failed.\n        :raises UnableToAuthenticate:\n            if authentication failed (when ``auth_strategy`` is non-``None``;\n            and note that this is a subclass of ``AuthenticationException``).\n        :raises socket.error:\n            if a socket error (other than connection-refused or\n            host-unreachable) occurred while connecting.\n        :raises NoValidConnectionsError:\n            if all valid connection targets for the requested hostname (eg IPv4\n            and IPv6) yielded connection-refused or host-unreachable socket\n            errors.\n        :raises SSHException:\n            if there was any other error connecting or establishing an SSH\n            session.\n    \n        .. versionchanged:: 1.15\n            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,\n            ``gss_deleg_creds`` and ``gss_host`` arguments.\n        .. versionchanged:: 2.3\n            Added the ``gss_trust_dns`` argument.\n        .. versionchanged:: 2.4\n            Added the ``passphrase`` argument.\n        .. versionchanged:: 2.6\n            Added the ``disabled_algorithms`` argument.\n        .. versionchanged:: 2.12\n            Added the ``transport_factory`` argument.\n        .. versionchanged:: 3.2\n            Added the ``auth_strategy`` argument.\n        \"\"\"\n        if not sock:\n            errors = {}\n            # Try multiple possible address families (e.g. IPv4 vs IPv6)\n            to_try = list(self._families_and_addresses(hostname, port))\n            for af, addr in to_try:\n                try:\n                    sock = socket.socket(af, socket.SOCK_STREAM)\n                    if timeout is not None:\n                        try:\n                            sock.settimeout(timeout)\n                        except:\n                            pass\n                    sock.connect(addr)\n                    # Break out of the loop on success\n                    break\n                except socket.error as e:\n                    # As mentioned in socket docs it is better\n                    # to close sockets explicitly\n                    if sock:\n                        sock.close()\n                    # Raise anything that isn't a straight up connection error\n                    # (such as a resolution error)\n                    if e.errno not in (ECONNREFUSED, EHOSTUNREACH):\n                        raise\n                    # Capture anything else so we know how the run looks once\n                    # iteration is complete. Retain info about which attempt\n                    # this was.\n                    errors[addr] = e\n    \n            # Make sure we explode usefully if no address family attempts\n            # succeeded. We've no way of knowing which error is the \"right\"\n            # one, so we construct a hybrid exception containing all the real\n            # ones, of a subclass that client code should still be watching for\n            # (socket.error)\n            if len(errors) == len(to_try):\n                raise NoValidConnectionsError(errors)\n    \n        if transport_factory is None:\n            transport_factory = Transport\n        t = self._transport = transport_factory(\n            sock,\n            gss_kex=gss_kex,\n            gss_deleg_creds=gss_deleg_creds,\n            disabled_algorithms=disabled_algorithms,\n        )\n        t.use_compression(compress=compress)\n        t.set_gss_host(\n            # t.hostname may be None, but GSS-API requires a target name.\n            # Therefore use hostname as fallback.\n            gss_host=gss_host or hostname,\n            trust_dns=gss_trust_dns,\n            gssapi_requested=gss_auth or gss_kex,\n        )\n        if self._log_channel is not None:\n            t.set_log_channel(self._log_channel)\n        if banner_timeout is not None:\n            t.banner_timeout = banner_timeout\n        if auth_timeout is not None:\n            t.auth_timeout = auth_timeout\n        if channel_timeout is not None:\n            t.channel_timeout = channel_timeout\n    \n        if port == SSH_PORT:\n            server_hostkey_name = hostname\n        else:\n            server_hostkey_name = \"[{}]:{}\".format(hostname, port)\n        our_server_keys = None\n    \n        our_server_keys = self._system_host_keys.get(server_hostkey_name)\n        if our_server_keys is None:\n            our_server_keys = self._host_keys.get(server_hostkey_name)\n        if our_server_keys is not None:\n            keytype = our_server_keys.keys()[0]\n            sec_opts = t.get_security_options()\n            other_types = [x for x in sec_opts.key_types if x != keytype]\n            sec_opts.key_types = [keytype] + other_types\n    \n>       t.start_client(timeout=timeout)\n\nD:\\Python\\lib\\site-packages\\paramiko\\client.py:451: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <paramiko.Transport at 0x95bc31f0 (unconnected)>\nevent = <threading.Event object at 0x000001E895B9B550>, timeout = 5\n\n    def start_client(self, event=None, timeout=None):\n        \"\"\"\n        Negotiate a new SSH2 session as a client.  This is the first step after\n        creating a new `.Transport`.  A separate thread is created for protocol\n        negotiation.\n    \n        If an event is passed in, this method returns immediately.  When\n        negotiation is done (successful or not), the given ``Event`` will\n        be triggered.  On failure, `is_active` will return ``False``.\n    \n        (Since 1.4) If ``event`` is ``None``, this method will not return until\n        negotiation is done.  On success, the method returns normally.\n        Otherwise an SSHException is raised.\n    \n        After a successful negotiation, you will usually want to authenticate,\n        calling `auth_password <Transport.auth_password>` or\n        `auth_publickey <Transport.auth_publickey>`.\n    \n        .. note:: `connect` is a simpler method for connecting as a client.\n    \n        .. note::\n            After calling this method (or `start_server` or `connect`), you\n            should no longer directly read from or write to the original socket\n            object.\n    \n        :param .threading.Event event:\n            an event to trigger when negotiation is complete (optional)\n    \n        :param float timeout:\n            a timeout, in seconds, for SSH2 session negotiation (optional)\n    \n        :raises:\n            `.SSHException` -- if negotiation fails (and no ``event`` was\n            passed in)\n        \"\"\"\n        self.active = True\n        if event is not None:\n            # async, return immediately and let the app poll for completion\n            self.completion_event = event\n            self.start()\n            return\n    \n        # synchronous, wait for a result\n        self.completion_event = event = threading.Event()\n        self.start()\n        max_time = time.time() + timeout if timeout is not None else None\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n>                   raise e\n\nD:\\Python\\lib\\site-packages\\paramiko\\transport.py:722: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <paramiko.Transport at 0x95bc31f0 (unconnected)>\n\n    def run(self):\n        # (use the exposed \"run\" method, because if we specify a thread target\n        # of a private method, threading.Thread will keep a reference to it\n        # indefinitely, creating a GC cycle and not letting Transport ever be\n        # GC'd. it's a bug in Thread.)\n    \n        # Hold reference to 'sys' so we can test sys.modules to detect\n        # interpreter shutdown.\n        self.sys = sys\n    \n        # active=True occurs before the thread is launched, to avoid a race\n        _active_threads.append(self)\n        tid = hex(id(self) & xffffffff)\n        if self.server_mode:\n            self._log(DEBUG, \"starting thread (server mode): {}\".format(tid))\n        else:\n            self._log(DEBUG, \"starting thread (client mode): {}\".format(tid))\n        try:\n            try:\n                self.packetizer.write_all(b(self.local_version + \"\\r\\n\"))\n                self._log(\n                    DEBUG,\n                    \"Local version/idstring: {}\".format(self.local_version),\n                )  # noqa\n>               self._check_banner()\n\nD:\\Python\\lib\\site-packages\\paramiko\\transport.py:2113: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <paramiko.Transport at 0x95bc31f0 (unconnected)>\n\n    def _check_banner(self):\n        # this is slow, but we only have to do it once\n        for i in range(100):\n            # give them 15 seconds for the first line, then just 2 seconds\n            # each additional line.  (some sites have very high latency.)\n            if i == 0:\n                timeout = self.banner_timeout\n            else:\n                timeout = 2\n            try:\n                buf = self.packetizer.readline(timeout)\n            except ProxyCommandFailure:\n                raise\n            except Exception as e:\n>               raise SSHException(\n                    \"Error reading SSH protocol banner\" + str(e)\n                )\nE               paramiko.ssh_exception.SSHException: Error reading SSH protocol banner[WinError 10054] 远程主机强迫关闭了一个现有的连接。\n\nD:\\Python\\lib\\site-packages\\paramiko\\transport.py:2296: SSHException\n\nDuring handling of the above exception, another exception occurred:\n\nself = <computer_test.test_cases.test_interfaces.test_cloud_server.TestCloudServer object at 0x000001E895AF7850>\n\n    @allure.suite('云服务器')\n    @allure.description(\"验证端口映射\")\n    # @pytest.mark.skip('暂时跳过')\n    def test_check_mapping(self):\n        case = self.cases[3]\n        allure.dynamic.title(case['case_title'])\n        allure.attach(body=self.cs.host, name=\"请求地址\")\n        try:\n            time.sleep(5)\n            public_ip = get_ini_data(CFI_COMPUTER, 'mapping', 'public_ip')\n            public_port = get_ini_data(CFI_COMPUTER, 'mapping', 'public_port')\n            username = case['case_data']['name']\n            passwd = case['case_data']['passwd']\n            print(public_ip, public_port, username, passwd)\n            mc = MySshClient(public_ip, public_port, username, str(passwd))\n            a1, a2, a3 = mc.exec_command('pwd')\n            a = a2.read().decode()\n            assert 'home' in a\n            logger.info(f\"测试编号:{case['case_id']},测试标题:{case['case_title']},成功!\")\n        except Exception as e:\n>           logger.error(\n                f\"测试编号:{case['case_title']},测试标题:{case['case_title']},执行失败!\", e)\n\ntest_cases\\test_interfaces\\test_cloud_server.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nD:\\Python\\lib\\logging\\__init__.py:1475: in error\n    self._log(ERROR, msg, args, **kwargs)\nD:\\Python\\lib\\logging\\__init__.py:1589: in _log\n    self.handle(record)\nD:\\Python\\lib\\logging\\__init__.py:1599: in handle\n    self.callHandlers(record)\nD:\\Python\\lib\\logging\\__init__.py:1661: in callHandlers\n    hdlr.handle(record)\nD:\\Python\\lib\\logging\\__init__.py:952: in handle\n    self.emit(record)\nC:\\Users\\HUAWEI\\AppData\\Roaming\\Python\\Python39\\site-packages\\_pytest\\logging.py:350: in emit\n    super().emit(record)\nD:\\Python\\lib\\logging\\__init__.py:1091: in emit\n    self.handleError(record)\nD:\\Python\\lib\\logging\\__init__.py:1083: in emit\n    msg = self.format(record)\nD:\\Python\\lib\\logging\\__init__.py:927: in format\n    return fmt.format(record)\nC:\\Users\\HUAWEI\\AppData\\Roaming\\Python\\Python39\\site-packages\\_pytest\\logging.py:114: in format\n    return super().format(record)\nD:\\Python\\lib\\logging\\__init__.py:663: in format\n    record.message = record.getMessage()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <LogRecord: root, 40, D:\\Huawei Share\\auto_test\\computer_test\\test_cases\\test_interfaces\\test_cloud_server.py, 120, \"测试编号:验证端口映射,测试标题:验证端口映射,执行失败!\">\n\n    def getMessage(self):\n        \"\"\"\n        Return the message for this LogRecord.\n    \n        Return the message for this LogRecord after merging any user-supplied\n        arguments with the message.\n        \"\"\"\n        msg = str(self.msg)\n        if self.args:\n>           msg = msg % self.args\nE           TypeError: not all arguments converted during string formatting\n\nD:\\Python\\lib\\logging\\__init__.py:367: TypeError"}, "description": "验证端口映射", "attachments": [{"name": "请求地址", "source": "0e9483fe-f49e-47b6-abaf-5856eb933bb9-attachment.attach"}, {"name": "log", "source": "86e775fb-635d-4b42-ac87-ef0d14036936-attachment.txt", "type": "text/plain"}], "start": 1706758553538, "stop": 1706758560847, "uuid": "d7ca738b-e7df-432d-8496-121b05ec9758", "historyId": "1b2455d5cc67e9ef72f534125e20200e", "testCaseId": "1b2455d5cc67e9ef72f534125e20200e", "fullName": "test_cases.test_interfaces.test_cloud_server.TestCloudServer#test_check_mapping", "labels": [{"name": "feature", "value": "云服务器模块"}, {"name": "parentSuite", "value": "云服务器"}, {"name": "epic", "value": "共享算力系统"}, {"name": "suite", "value": "云服务器"}, {"name": "subSuite", "value": "TestCloudServer"}, {"name": "host", "value": "LAPTOP-UIN85NG6"}, {"name": "thread", "value": "24040-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_cases.test_interfaces.test_cloud_server"}]}